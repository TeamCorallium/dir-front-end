'use strict';

let isSyncing = (() => {
  var _ref = _asyncToGenerator(function* (travis) {
    try {
      var res = yield promisify(travis.users.get.bind(travis))();
      return _.get(res, 'user.is_syncing');
    } catch (e) {}
  });

  return function isSyncing(_x) {
    return _ref.apply(this, arguments);
  };
})();

let syncTravis = (() => {
  var _ref2 = _asyncToGenerator(function* (travis) {
    try {
      yield promisify(travis.users.sync.post.bind(travis))();
    } catch (e) {
      if (e.message !== 'Sync already in progress. Try again later.') throw e;
    }

    while (yield isSyncing(travis)) {
      yield delay(1000);
    }
  });

  return function syncTravis(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

let setEnvVar = (() => {
  var _ref3 = _asyncToGenerator(function* (travis, name, value) {
    const tagent = travis.agent;
    const response = yield promisify(tagent.request.bind(tagent))('GET', `/settings/env_vars?repository_id=${travis.repoid}`);
    let envid = _.get(_.find(response.env_vars, ['name', name]), 'id');
    envid = envid ? `/${envid}` : '';

    yield yield promisify(tagent.request.bind(tagent))(envid ? 'PATCH' : 'POST', `/settings/env_vars${envid}?repository_id=${travis.repoid}`, { env_var: { name: name, value: value, public: false } });
  });

  return function setEnvVar(_x3, _x4, _x5) {
    return _ref3.apply(this, arguments);
  };
})();

let createTravisYml = (() => {
  var _ref4 = _asyncToGenerator(function* (info) {
    const answers = yield inquirer.prompt([{
      type: 'confirm',
      name: 'yml',
      message: 'Do you want a `.travis.yml` file with semantic-release setup?',
      default: true
    }]);
    if (!answers.yml) return;
    const tyml = yaml.safeDump(travisyml);
    try {
      accessSync('.travis.yml');

      var _ref5 = yield inquirer.prompt([{
        type: 'confirm',
        name: 'ok',
        default: false,
        message: 'Do you want to overwrite the existing `.travis.yml`?'
      }]);

      const ok = _ref5.ok;

      if (!ok) return;
    } catch (e) {}
    log.verbose('Writing `.travis.yml`.');
    writeFileSync('.travis.yml', tyml);
    log.info('Successfully created `.travis.yml`.');
  });

  return function createTravisYml(_x6) {
    return _ref4.apply(this, arguments);
  };
})();

let setUpTravis = (() => {
  var _ref6 = _asyncToGenerator(function* (pkg, info) {
    const travis = info.travis;

    log.info('Syncing repositories...');
    yield syncTravis(travis);

    travis.repoid = _.get((yield promisify(travis.repos(info.ghrepo.slug[0], info.ghrepo.slug[1]).get.bind(travis))()), 'repo.id');

    if (!travis.repoid) throw new Error('Could not get repo id');

    var _ref7 = yield promisify(travis.hooks(travis.repoid).put.bind(travis))({
      hook: { active: true }
    });

    const result = _ref7.result;

    if (!result) throw new Error('Could not enable hook on Travis CI');
    log.info('Successfully created Travis CI hook.');

    yield setEnvVar(travis, 'GH_TOKEN', info.github.token);
    yield setEnvVar(travis, 'NPM_TOKEN', info.npm.token);
    log.info('Successfully set environment variables on Travis CI.');
    yield createTravisYml(info);
  });

  return function setUpTravis(_x7, _x8) {
    return _ref6.apply(this, arguments);
  };
})();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var _require = require('fs');

const readFileSync = _require.readFileSync,
      writeFileSync = _require.writeFileSync,
      accessSync = _require.accessSync;

var _require2 = require('path');

const join = _require2.join;


const _ = require('lodash');

var _require3 = require('bluebird');

const promisify = _require3.promisify,
      delay = _require3.delay;

const home = require('user-home');
const inquirer = require('inquirer');
const Travis = require('travis-ci');
const yaml = require('js-yaml');
const log = require('npmlog');

const travisyml = {
  language: 'node_js',
  cache: {
    directories: ['node_modules']
  },
  notifications: {
    email: false
  },
  node_js: ['7', '6', '4'],
  before_script: ['npm prune'],
  after_success: ['npm run semantic-release'],
  branches: {
    // ignore git tags created by semantic-release, like "v1.2.3"
    except: [/^v\d+\.\d+\.\d+$/.toString()]
  }
};

module.exports = (() => {
  var _ref8 = _asyncToGenerator(function* (endpoint, pkg, info) {
    const travisPath = join(home, '.travis/config.yml');

    try {
      const travisConfig = yaml.safeLoad(readFileSync(travisPath, 'utf8'));
      var token = travisConfig.endpoints[`${endpoint}/`].access_token;
    } catch (e) {
      log.info('Could not load Travis CI config for endpoint.');
    }

    const travis = info.travis = new Travis({
      version: '2.0.0',
      headers: {
        // Won't work with a different user-agent ¯\_(ツ)_/¯
        'User-Agent': 'Travis'
      }
    });
    travis.agent._endpoint = endpoint;

    if (token) travis.agent.setAccessToken(token);else yield promisify(travis.authenticate.bind(travis))({ github_token: info.github.token });

    yield setUpTravis(pkg, info);
  });

  return function (_x9, _x10, _x11) {
    return _ref8.apply(this, arguments);
  };
})();