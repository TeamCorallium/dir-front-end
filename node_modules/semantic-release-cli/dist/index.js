'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var _require = require('fs');

const readFileSync = _require.readFileSync,
      writeFileSync = _require.writeFileSync;


const _ = require('lodash');

var _require2 = require('bluebird');

const promisify = _require2.promisify;

const nopt = require('nopt');
const npm = require('npm');
const request = require('request-promise').defaults({ json: true });

const getLog = require('./lib/log');

const ownPkg = require('../package.json');
let pkg = JSON.parse(readFileSync('./package.json'));

require('update-notifier')({
  pkg: _.defaults(ownPkg, { version: '0.0.0' })
}).notify();

const knownOptions = {
  tag: String,
  version: Boolean,
  help: Boolean,
  keychain: Boolean,
  'ask-for-passwords': Boolean,
  'gh-token': String,
  'npm-token': String,
  'gh-username': String,
  'npm-username': String
};

const shortHands = {
  v: ['--version'],
  h: ['--help']
};

module.exports = (() => {
  var _ref = _asyncToGenerator(function* (argv) {
    let info = {
      options: _.defaults(nopt(knownOptions, shortHands, argv, 2), {
        keychain: true,
        tag: 'latest'
      })
    };

    if (info.options.version) {
      console.log(ownPkg.version || 'development');
      process.exit(0);
    }

    if (info.options.argv.remain[0] !== 'setup' && info.options.argv.remain[0] !== 'init' || info.options.help) {
      console.log(`
semantic-release-cli

Usage:
  semantic-release-cli setup [--tag=<String>]

Options:
  -h --help            Show this screen.
  -v --version         Show version.
  --[no-]keychain      Use keychain to get passwords [default: true].
  --ask-for-passwords  Ask for the passwords even if passwords are stored [default: false].
  --tag=<String>       npm tag to install [default: 'latest'].
  --gh-token=<String>  GitHub auth token
  --npm-token=<String> npm auth token
  --gh-username=<String>  GitHub username
  --npm-username=<String>  npm username

Aliases:
  init                 setup`);
      process.exit(0);
    }

    try {
      var config = (yield promisify(npm.load.bind(npm))({ progress: false })).config;
    } catch (e) {
      console.log('Failed to load npm config.', e);
      process.exit(1);
    }

    info.loglevel = config.get('loglevel') || 'warn';
    const log = info.log = getLog(info.loglevel);

    try {
      yield require('./lib/repository')(pkg, info);
      yield require('./lib/npm')(pkg, info);
      yield require('./lib/github')(pkg, info);
      yield require('./lib/ci')(pkg, info);
    } catch (err) {
      log.error(err);
      process.exit(1);
    }

    pkg.version = '0.0.0-development';

    pkg.scripts = pkg.scripts || {};
    pkg.scripts['semantic-release'] = 'semantic-release pre && npm publish && semantic-release post';

    pkg.repository = pkg.repository || {
      type: 'git',
      url: info.giturl
    };

    if (info.ghrepo.private && !pkg.publishConfig) {
      pkg.publishConfig = { access: 'restricted' };
    }

    try {
      var _ref2 = yield request('https://registry.npmjs.org/semantic-release');

      const distTags = _ref2['dist-tags'];

      pkg.devDependencies = pkg.devDependencies || {};
      pkg.devDependencies['semantic-release'] = `^${distTags[info.options.tag]}`;
    } catch (e) {
      log.error('Could not get latest `semantic-release` version.', e);
    }

    log.verbose('Writing `package.json`.');
    writeFileSync('package.json', `${JSON.stringify(pkg, null, 2)}\n`);
    log.info('Done.');
  });

  return function (_x) {
    return _ref.apply(this, arguments);
  };
})();